# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

EMS-SEP490-BE is a Spring Boot backend for an Education Management System (EMS) designed for language training centers. The system manages multi-tenant operations (centers → branches) including course curriculum, class scheduling, teacher assignments, student enrollments, attendance tracking, and request workflows.

**Tech Stack:**
- Spring Boot 3.5.6
- Java 21
- PostgreSQL 16 (with custom enum types)
- Spring Data JPA (Hibernate)
- Spring Security
- Lombok
- Maven
- Docker & Docker Compose

## **Implementation Plan: Core Principles**

**1. Code Quality & Structure:**

- **Clean Implementation:** The implementation must be clean, avoiding unnecessary code, complexity, and "code smells." Adhere strictly to established coding standards and best practices (e.g., SOLID, DRY).
- **No Redundancy (DRY - Don't Repeat Yourself):** Actively prevent code duplication. Abstract and reuse components, functions, and logic wherever possible.
- **Logical Soundness & Correct Algorithms:** Ensure all logic is correct and the algorithms used are efficient and appropriate for the given problem.

**2. System Integrity & Performance:**

- **Prevent Race Conditions:** Proactively identify and prevent potential race conditions to ensure data integrity and system stability, especially in concurrent operations.
- **Avoid Over-engineering:** The solution must not be over-engineered. Implement what is necessary to meet the current requirements without adding speculative features or unnecessary complexity.

**3. Development Approach:**

- **Adhere to Best Practices:** Always follow the best and most current industry-standard approaches for the technologies and patterns being used.
- **Maintain a Holistic View:** Always consider the overall architecture and the impact of your changes on the entire system. Ensure new implementations integrate seamlessly.
- **Focus on the Story & Scope:** Concentrate on delivering the user story at hand. Ensure the implementation directly serves the story's requirements and stays within the defined scope for the MVP (Minimum Viable Product). The primary goal is a functional, demonstrable feature that meets the story's acceptance criteria.

**4. Final Deliverable:**

- **Solid & Maintainable Code:** The final code must be robust, reliable, well-documented, and easy for other developers to understand, modify, and maintain in the future.


## Development Commands

### Building & Running (Local)
```bash
# Build the project
./mvnw clean install

# Run the application (will start on default port 8080)
./mvnw spring-boot:run

# Run tests
./mvnw test

# Run a specific test class
./mvnw test -Dtest=ClassName

# Run a specific test method
./mvnw test -Dtest=ClassName#methodName

# Package without running tests
./mvnw clean package -DskipTests

# Run with debug enabled (port 5005)
./mvnw spring-boot:run -Dspring-boot.run.jvmArguments="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005"
```

### Docker Commands (Recommended for Development)
```bash
# Build and start all services (PostgreSQL + Spring Boot + pgAdmin)
docker-compose up -d

# View application logs
docker-compose logs -f app

# View PostgreSQL logs
docker-compose logs -f postgres

# Stop all services
docker-compose down

# Stop and remove volumes (completely reset database)
docker-compose down -v

# Rebuild application image after code changes
docker-compose build app

# Restart a specific service
docker-compose restart app

# Execute commands in containers
docker exec -it ems-spring-boot sh
docker exec -it ems-postgres psql -U postgres -d ems

# Check container status
docker-compose ps

# Clean up everything
docker-compose down -v --remove-orphans
```

### Service Access
| Service | URL | Credentials |
|---------|-----|-------------|
| Spring Boot API | http://localhost:8080 | - |
| Health Check | http://localhost:8080/actuator/health | - |
| PostgreSQL | localhost:5432 | user: `postgres` / pass: `979712` |
| pgAdmin | http://localhost:5050 | email: `admin@ems.com` / pass: `admin123` |

### Database Setup
- PostgreSQL database required: `ems` on `localhost:5432` (or `postgres:5432` inside Docker network)
- Default credentials in `application.yml` (username: postgres, password: 979712)
- Schema initialization: `schema.sql` creates enum types on first run (with `continue-on-error: true`)
- Hibernate DDL mode: `update` (auto-creates/updates tables from entities)

**IMPORTANT:** The `schema.sql` file ONLY defines PostgreSQL enum types. Tables are auto-generated by Hibernate from entity classes.

## Architecture & Design Patterns

### User Roles & Access Control

The system implements Role-Based Access Control (RBAC) with the following role hierarchy:

**1. ADMIN (System Administrator)**
- **Scope:** Entire system
- **Responsibilities:** System configuration, user account management, global settings
- **Access:** All centers and branches

**2. MANAGER (Operations Manager)**
- **Scope:** Multiple branches or entire system
- **Responsibilities:**
    - **Strategic management:** KPI monitoring, performance analytics, resource allocation across branches
    - **High-level approvals:** Course approvals, strategic decisions (opening branches, hiring policies)
    - **Cross-branch coordination:** Manage teacher allocation, resource optimization across branches
    - **Executive oversight:** Review executive dashboards, handle escalated requests
- **Access:** All branches under their management (configured via `user_branches`)
- **Key Distinction:** Focuses on **system-wide operational excellence** rather than day-to-day branch operations

**3. CENTER_HEAD (Branch Director)**
- **Scope:** ONE specific branch
- **Responsibilities:**
    - **Branch operations:** Direct management of one branch's daily activities
    - **Operational approvals:** Approve classes, handle branch-specific requests
    - **Resource management:** Manage rooms, resources, and staff within the branch
    - **Branch performance:** Monitor and improve branch-level KPIs
- **Access:** Single branch only (configured via `user_branches`)
- **Key Distinction:** Focuses on **direct branch management** and operational execution

**4. ACADEMIC STAFF (Giáo vụ)**
- **Scope:** Assigned branch(es)
- **Responsibilities:** Daily operations (class creation, enrollment, request processing, teacher/resource assignment)
- **Access:** Branches assigned via `user_branches`

**5. SUBJECT LEADER**
- **Scope:** Subject/curriculum domain
- **Responsibilities:** Curriculum design, course creation, learning outcome mapping
- **Access:** Subject-specific, branch-independent

**6. TEACHER**
- **Scope:** Assigned classes/sessions
- **Responsibilities:** Teaching, attendance recording, grading
- **Access:** Sessions assigned via `teaching_slot`

**7. STUDENT**
- **Scope:** Enrolled classes
- **Responsibilities:** Attend sessions, submit requests
- **Access:** Classes enrolled via `enrollment`

**8. QA (Quality Assurance)**
- **Scope:** Monitoring role
- **Responsibilities:** Quality monitoring, QA reports, feedback aggregation
- **Access:** Read-only across branches for monitoring

**Important Notes:**
- **Manager vs Center Head distinction:**
    - **MANAGER:** Strategic, multi-branch, system-wide operations, high-level approvals
    - **CENTER_HEAD:** Tactical, single-branch, day-to-day operations, operational approvals
- Both roles can approve courses and classes, but Manager has cross-branch authority
- Access control enforced via `user_branches` table (many-to-many relationship)
- Some operations require either MANAGER OR CENTER_HEAD approval (implementation uses `@PreAuthorize("hasAnyRole('MANAGER', 'CENTER_HEAD')")`)

### Session-First Design Pattern
The core architectural principle is that **session is the source of truth** for all schedule-related operations. This pattern affects:

1. **Class Creation Flow:**
    - Academic Staff creates a `ClassEntity` (draft status)
    - System auto-generates `SessionEntity` records from course template (`Course → CoursePhase → CourseSession`)
    - Sessions are created based on `start_date`, `schedule_days[]`, and `time_slot_template`
    - Generation logic: `session_per_week` × `duration_weeks` = total sessions

2. **Student Enrollment Flow:**
    - When a student enrolls in a class, system auto-generates `StudentSession` records
    - Each `StudentSession` maps to a `SessionEntity` and tracks individual attendance
    - Late enrollment (mid-course) only creates StudentSession for future sessions
    - Schedule changes at session level automatically propagate to all enrolled students

3. **Request Processing:**
    - All schedule modifications (reschedule, cancellation, make-up) operate on `SessionEntity`
    - Changes to sessions trigger updates to related `StudentSession`, `TeachingSlot`, and `SessionResource` records
    - This ensures referential integrity and complete audit trail

### Domain Model Organization

**Core Entities (42 total):**

1. **Organization & Infrastructure:**
    - `Center`, `Branch` (multi-tenant structure)
    - `Resource` (unified model for ROOM and VIRTUAL/Zoom)
    - `TimeSlotTemplate` (defines allowed class times per branch)

2. **Academic Curriculum:**
    - `Subject → Level → Course → CoursePhase → CourseSession` (template hierarchy)
    - `Plo` (Program Learning Outcomes), `Clo` (Course Learning Outcomes)
    - `PloCloMapping`, `CourseSessionCloMapping` (outcome tracking)
    - `CourseMaterial` (linked to Course/Phase/Session)

3. **People:**
    - `UserAccount → UserRole → Role` (RBAC system)
    - `UserBranch` (multi-branch access control)
    - `Student`, `Teacher` (1-1 mapping with UserAccount)
    - `TeacherSkill`, `TeacherAvailability`, `TeacherAvailabilityOverride`

4. **Operations:**
    - `ClassEntity` (instance of a Course at a Branch)
    - `SessionEntity` (actual class meeting, auto-generated from CourseSession template)
    - `SessionResource` (room/zoom assignment)
    - `TeachingSlot` (teacher assignment to session with skill and role)
    - `Enrollment` (student registration in class)
    - `StudentSession` (student's individual session record with attendance)

5. **Assessment & Feedback:**
    - `Assessment`, `Score`
    - `StudentFeedback`, `QaReport`

6. **Request Workflows:**
    - `StudentRequest` (absence, makeup, transfer, reschedule)
    - `TeacherRequest` (leave, swap, ot, reschedule)

### Composite Key Pattern

Many entities use composite primary keys for junction tables and relationships:
- `UserRoleId` (userId + roleId)
- `UserBranchId` (userId + branchId)
- `TeacherSkillId` (teacherId + skill)
- `StudentSessionId` (studentId + sessionId)
- `TeachingSlotId` (sessionId + teacherId)
- `SessionResourceId` (sessionId + resourceId)
- `PloCloMappingId` (ploId + cloId)
- `CourseSessionCloMappingId` (courseSessionId + cloId)

**Implementation Pattern:**
```java
// Composite key class in entities/ids/
@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
public class StudentSessionId implements Serializable {
    private Long studentId;
    private Long sessionId;
}

// Entity using composite key
@Entity
@IdClass(StudentSessionId.class)
public class StudentSession {
    @Id
    private Long studentId;

    @Id
    private Long sessionId;

    // Other fields...
}
```

### Enum Management

PostgreSQL enums are defined in `schema.sql` and must be created BEFORE Hibernate runs. Entity classes use `@Enumerated(EnumType.STRING)` to map to these database enums.

**16 PostgreSQL Enum Types:**
- `session_status_enum` (planned, cancelled, done)
- `session_type_enum` (CLASS, MAKEUP, EXAM, OTHER)
- `attendance_status_enum` (planned, present, absent, late, excused, remote)
- `enrollment_status_enum` (enrolled, waitlisted, transferred, dropped, completed)
- `request_status_enum` (pending, approved, rejected, cancelled)
- `teacher_request_type_enum` (leave, swap, ot, reschedule)
- `student_request_type_enum` (absence, makeup, transfer, reschedule)
- `resource_type_enum` (ROOM, VIRTUAL)
- `modality_enum` (OFFLINE, ONLINE, HYBRID)
- `skill_enum` (general, reading, writing, speaking, listening)
- `teaching_role_enum` (primary, assistant)
- `branch_status_enum` (active, inactive, closed, planned)
- `class_status_enum` (draft, scheduled, ongoing, completed, cancelled)
- `subject_status_enum` (active, inactive)
- `assessment_kind_enum` (quiz, midterm, final, assignment, project, oral, practice, other)
- Plus supporting enums

**Pattern for adding new enums:**
1. Add `CREATE TYPE` statement to `schema.sql` (e.g., `CREATE TYPE status_enum AS ENUM ('active','inactive');`)
2. Create corresponding Java enum in `entities/enums/`
3. Use `@Enumerated(EnumType.STRING)` in entity field
4. For array types (e.g., `skill_enum[]`), also add `@JdbcTypeCode(SqlTypes.ARRAY)`

**Example for array types:**
```java
@JdbcTypeCode(SqlTypes.ARRAY)
@Column(columnDefinition = "smallint[]")
private List<Short> scheduleDays;  // For ClassEntity.schedule_days
```

### Exception Handling

Centralized exception handling via `GlobalExceptionHandler` (@ControllerAdvice):
- All API responses follow `ResponseObject<T>` pattern (status, message, data)
- Custom exceptions extend `CustomException` with `ErrorCode`
- Standard exceptions (validation, not found, illegal argument) are handled uniformly

**Response Structure:**
```java
ResponseObject<T> {
    int status;        // HTTP status code
    String message;    // Response message
    T data;           // Generic data payload
}
```

### Service Implementation Pattern

All services follow a consistent structure using Lombok and Spring annotations:

```java
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class BranchServiceImpl implements BranchService {
    private final BranchRepository branchRepository;

    @Transactional(readOnly = true)
    public BranchDetailDTO getBranchById(Long id) {
        log.info("Getting branch by ID: {}", id);
        // Implementation
    }

    public BranchDTO createBranch(CreateBranchRequestDTO request) {
        log.info("Creating branch: {}", request);
        // Implementation
    }
}
```

**Key Patterns:**
- `@RequiredArgsConstructor` for constructor injection (replaces @Autowired)
- `@Slf4j` for logging (provides log field automatically)
- `@Transactional` at class level for write operations
- `@Transactional(readOnly = true)` for read-only queries (optimization)
- Always log important operations (log.info) and errors (log.error)

### Package Structure

```
org.fyp.emssep490be/
├── configs/           (Spring configurations - currently empty)
├── controllers/       (REST endpoints)
│   ├── auth/          (Authentication: login, refresh)
│   ├── branch/        (Branch management)
│   ├── timeslot/      (Time slot management)
│   ├── resource/      (Resource/Room/Zoom)
│   ├── subject/       (Subject management)
│   ├── level/         (Level management)
│   ├── course/        (Course management)
│   ├── coursephase/   (Course phase management)
│   └── [+ 10 more domain controllers]
├── dtos/              (Data Transfer Objects including ResponseObject)
│   ├── auth/          (Login, refresh token DTOs)
│   ├── branch/        (Branch DTOs)
│   └── [+ DTOs for all domains]
├── entities/          (JPA entities - 42 domain models)
│   ├── enums/         (16 enum types matching PostgreSQL enums)
│   └── ids/           (Composite key classes)
├── exceptions/        (CustomException, ErrorCode, GlobalExceptionHandler)
├── repositories/      (Spring Data JPA repositories - 22 repositories)
├── services/          (Business logic layer)
│   ├── auth/          (Authentication service)
│   ├── branch/        (Branch service)
│   └── [+ services for all domains]
│       └── impl/      (Service implementations)
└── utils/             (Helper utilities - currently empty)
```

## Key Business Rules & Workflows

### 1. Course Approval Workflow
- Subject Leader creates Course → **Manager** approves (`approved_by_manager`, `approved_at`)
- **Note:** Manager handles course approvals as a **strategic decision** (curriculum standardization across branches)
- Only approved courses can be used to create classes
- Rejection requires `rejection_reason`

### 2. Class Creation & Session Generation
- Class starts in `draft` status
- System auto-generates sessions from course template based on:
    - `Course.session_per_week` × `Course.duration_weeks`
    - `ClassEntity.schedule_days[]` (which days of week: 2=Monday, 3=Tuesday, etc.)
    - `ClassEntity.start_date` + week offset calculation
- **Academic Staff** (at branch level) assigns teachers/resources, then submits for approval
- **Center Head** (for their branch) OR **Manager** (cross-branch authority) approves → status becomes `scheduled`
- **Note:** Center Head approves classes for operational execution at their branch; Manager can approve across all branches

### 3. Enrollment & Synchronization
- Students can only enroll in `scheduled` or `ongoing` classes
- Upon enrollment, system creates `StudentSession` for all planned sessions
- Late enrollment (mid-course): only creates StudentSession for future sessions
- When class schedule changes (reschedule), all StudentSession records sync automatically

### 4. Request Processing (Key Patterns)

**Teacher Leave → Substitution:**
- Teacher submits `TeacherRequest(type='leave')`
- System queries available substitute teachers (skill match + availability + no conflict)
- If substitute found: approve leave → create OT request for substitute → update `TeachingSlot`
- If no substitute: options are reschedule or cancel

**Student Make-up:**
- Student selects missed session → system suggests make-up sessions (same `course_session_id`, different class)
- Upon approval: mark original as `excused`, create new `StudentSession(is_makeup=true)` for make-up session

**Transfer Between Classes:**
- Requires same `course_id` to map remaining sessions by `course_session_id`
- System identifies cutoff point (`left_session_id`, `join_session_id`)
- Updates both enrollments and syncs StudentSession records

### 5. Attendance Locking
- Teachers record attendance via `StudentSession.attendance_status`
- System can lock attendance T hours after session to prevent changes (configured in system settings)

## Important Constraints & Validations

1. **Unique Constraints (enforced by database):**
    - `(center_id, branch_code)` - branch codes unique per center
    - `(subject_id, level_code)` - level codes unique per subject
    - `(branch_id, class_code)` - class codes unique per branch
    - `(phase_id, sequence_no)` - course session sequence unique per phase
    - `(assessment_id, student_id)` - one score per student per assessment
    - `(class_id, student_id)` - one enrollment per student per class
    - Many composite primary keys for junction tables

2. **Business Validations:**
    - Course must be approved before creating class
    - Class must be approved before enrollment
    - Enrollment capacity check (`enrolled < max_capacity`)
    - Resource conflict detection (same resource, overlapping time)
    - Teacher conflict detection (same teacher, overlapping sessions)
    - PLO-CLO mapping validation (must belong to same subject)

3. **Audit Trail Requirements:**
    - Track `created_by`, `created_at` for critical operations
    - Track `approved_by`, `approved_at` for approval workflows
    - Track `decided_by`, `decided_at` for request processing
    - Track `graded_by`, `graded_at` for score entry

## Development Notes

### **Implementation Plan: Core Principles**

**1. Code Quality & Structure:**

- **Clean Implementation:** The implementation must be clean, avoiding unnecessary code, complexity, and "code smells." Adhere strictly to established coding standards and best practices (e.g., SOLID, DRY).
- **No Redundancy (DRY - Don't Repeat Yourself):** Actively prevent code duplication. Abstract and reuse components, functions, and logic wherever possible.
- **Logical Soundness & Correct Algorithms:** Ensure all logic is correct and the algorithms used are efficient and appropriate for the given problem.

**2. System Integrity & Performance:**

- **Prevent Race Conditions:** Proactively identify and prevent potential race conditions to ensure data integrity and system stability, especially in concurrent operations.
- **Avoid Over-engineering:** The solution must not be over-engineered. Implement what is necessary to meet the current requirements without adding speculative features or unnecessary complexity.

**3. Development Approach:**

- **Adhere to Best Practices:** Always follow the best and most current industry-standard approaches for the technologies and patterns being used.
- **Maintain a Holistic View:** Always consider the overall architecture and the impact of your changes on the entire system. Ensure new implementations integrate seamlessly.
- **Focus on the Story & Scope:** Concentrate on delivering the user story at hand. Ensure the implementation directly serves the story's requirements and stays within the defined scope for the MVP (Minimum Viable Product). The primary goal is a functional, demonstrable feature that meets the story's acceptance criteria.

**4. Final Deliverable:**

- **Solid & Maintainable Code:** The final code must be robust, reliable, well-documented, and easy for other developers to understand, modify, and maintain in the future.

### When Adding New Entities:
1. Create enum types in `schema.sql` if needed (with `continue-on-error: true`)
2. Create corresponding Java enum in `entities/enums/`
3. Create entity class with proper relationships (@ManyToOne, @OneToMany)
4. Use Lombok annotations (@Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor)
5. For composite keys, create ID class in `entities/ids/` with `@Embeddable` or use `@IdClass`
6. Add unique constraints via `@Table(uniqueConstraints = {...})`
7. For array types, use `@JdbcTypeCode(SqlTypes.ARRAY)` with proper `columnDefinition`
8. Create repository interface extending `JpaRepository`

### When Implementing Controllers:
- Follow RESTful conventions matching the API design in `docs/api-design.md`
- Return `ResponseObject<T>` from all endpoints
- Use `@Valid` for request body validation
- Leverage GlobalExceptionHandler for error handling
- Never include business logic in controllers - delegate to services

### When Implementing Services:
- Use the standard pattern: `@Service @RequiredArgsConstructor @Slf4j @Transactional`
- Add logging for important operations: `log.info("Operation starting...", params)`
- Use `@Transactional(readOnly = true)` for read-only methods
- Keep transaction scope as small as possible
- Handle exceptions and let GlobalExceptionHandler convert to ResponseObject

### Database Migrations:
- Hibernate `ddl-auto: update` is currently enabled for development
- For production, switch to Flyway/Liquibase for versioned migrations
- Never modify `schema.sql` enum definitions after initial creation (PostgreSQL doesn't support enum modification easily)
- Use ALTER TYPE ... ADD VALUE if you must add enum values (cannot remove or rename)

### Docker Considerations:
- Application connects to PostgreSQL via hostname `postgres:5432` inside Docker network
- For local development without Docker, use `localhost:5432`
- Multi-stage Docker build: Maven build stage + JRE runtime stage (Alpine-based)
- Health check uses actuator endpoint: `/actuator/health`
- Non-root user in container for security (spring:spring)

### Testing Strategy:
- Unit tests: service layer business logic
- Integration tests: repository layer with @DataJpaTest
- Controller tests: with @WebMvcTest and MockMvc
- End-to-end tests: full workflow scenarios (enrollment → attendance → grading)

### Common Pitfalls to Avoid:
1. **N+1 Query Problem:** Use JOIN FETCH or entity graphs for lazy-loaded relationships
2. **Transaction Boundaries:** Don't access lazy-loaded entities outside @Transactional methods
3. **Enum Modification:** Cannot easily change PostgreSQL enums after creation
4. **Array Types:** Must use `@JdbcTypeCode(SqlTypes.ARRAY)` for PostgreSQL arrays
5. **Composite Keys:** Always implement `equals()` and `hashCode()` in ID classes
6. **Docker Networking:** Inside containers, use service names (e.g., `postgres:5432`), not `localhost`

## Reference Documentation

- API Design: `docs/api-design.md` (complete RESTful API specification)
- Feature List: `docs/feature-list.md` (detailed business requirements and workflows)
- Spring Boot Guides: `HELP.md`
- Database Schema: PostgreSQL enums in `src/main/resources/schema.sql`
- Project Setup: `README.md` (Vietnamese documentation with detailed setup instructions)

## Project Context

This is a capstone project (SEP490) for a final year project (FYP). The system is designed for real-world deployment at language training centers with multi-branch operations. Focus areas include:
- Robust scheduling with conflict detection
- Automated session generation and synchronization
- Comprehensive request/approval workflows
- Complete audit trail for compliance
- Multi-tenant access control

## Quick Reference

**File Paths (Windows):**
```
d:\Workspace\projects\EMS-SEP490\ems-sep490-be\pom.xml
d:\Workspace\projects\EMS-SEP490\ems-sep490-be\src\main\resources\application.yml
d:\Workspace\projects\EMS-SEP490\ems-sep490-be\src\main\resources\schema.sql
d:\Workspace\projects\EMS-SEP490\ems-sep490-be\src\main\java\org\fyp\emssep490be\
```

**Most Common Commands:**
```bash
# Quick start with Docker
docker-compose up -d
docker-compose logs -f app

# Local development
./mvnw spring-boot:run

# Run tests
./mvnw test

# Health check
curl http://localhost:8080/actuator/health
```

**Current Implementation Status:**
- ✅ Entity design (42 entities)
- ✅ Enum types (16 PostgreSQL enums + Java equivalents)
- ✅ Exception handling framework
- ✅ Repository interfaces (22 repositories)
- ✅ Service interfaces with TODO comments
- ✅ Controller stubs
- ✅ DTOs for auth, branch, and other domains
- ⏳ Service implementations (in progress)
- ⏳ Controller implementations (in progress)
- ⏳ Unit and integration tests (to be implemented)
- ⏳ Session auto-generation logic (to be implemented)
- ⏳ Enrollment synchronization logic (to be implemented)
- ⏳ Conflict detection algorithms (to be implemented)
